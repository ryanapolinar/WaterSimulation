<html><head>
<title>Wave on GPU</title>

<script src="../CanvasMatrix.js" type="text/javascript"></script>
<script src="../Controls.js" type="text/javascript"></script>

<script id="shader-vs-show" type="x-shader/x-vertex">
  attribute vec2 aPos;
  uniform mat4 mvMatrix;
  uniform mat4 prMatrix;
  uniform float d;
  varying vec4 color;
  uniform sampler2D samp;
  const vec4 dirDif = vec4(0., 0., 1., 0.);
  const vec4 dirHalf = vec4(-.4034, .259, .8776, 0.);
void main(void) {
   float h = texture2D(samp, aPos ).r;
   gl_Position = prMatrix * mvMatrix * vec4(aPos, h, 1.);
   vec3 aNorm = vec3(texture2D(samp, vec2(aPos.x + d, aPos.y)).r -
     texture2D(samp, vec2(aPos.x - d, aPos.y)).r,
     texture2D(samp, vec2(aPos.x, aPos.y + d)).r -
     texture2D(samp, vec2(aPos.x, aPos.y - d)).r, -d-d);
   aNorm = normalize(aNorm);
   vec4 rotNorm = mvMatrix * vec4(aNorm, .0);
   float i = max( 0., abs(dot(rotNorm, dirDif)) );
   color = vec4(.0, .5*i, i, 1.);
   i = pow( max( 0., abs(dot(rotNorm, dirHalf)) ), 120.);
   color += vec4(i, i, i, 0.);
}
</script>

<script id="shader-fs-show" type="x-shader/x-fragment">
precision highp float;
  varying vec4 color;
void main(void) {
   gl_FragColor = color;
}
</script>

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec2 aPos;
  varying   vec2 vTC;
void main(void) {
   gl_Position = vec4(aPos, 0., 1.);
   vTC = .5*aPos + .5;
}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
precision highp float;
  uniform sampler2D samp;
  uniform sampler2D samp1;
  varying vec2 vTC;
  const float d = 1./512., dth2 = .4;
void main(void) {
   float u = texture2D(samp, vTC).r;
   float u1  = texture2D(samp1, vTC).r;
   u = 2.*u1 - u +
     (texture2D(samp1, vec2(vTC.x, vTC.y + d) ).r +
      texture2D(samp1, vec2(vTC.x, vTC.y - d) ).r +
      texture2D(samp1, vec2(vTC.x + d, vTC.y) ).r +
      texture2D(samp1, vec2(vTC.x - d, vTC.y) ).r +
      - 4.*u1)*dth2;
   gl_FragColor = vec4(u, 0., 0., 0. );
}
</script>

<script type="text/javascript">

var prog, prg_show, FBO, FBO1, FBO2, texture, texture1, texture2, c_w, c_h,
    timer, delay = 0, frames = 0, time, animation, pix,
    n = 512, n1 = n-1,
    prMatrix, mvMat, mvMatLoc, rotMat, posLocation,
    sampLoc, samp1Loc
function main() {
   initGL()
   transl = -1.5
   c_w = window.innerWidth - 50
   c_h = window.innerHeight - 10
   canvas.width = c_w;   canvas.height = c_h
   var err = "Your browser does not support "
   var ext
   try { ext = gl.getExtension("OES_texture_float")
   } catch(e) {}
   if ( !ext ) {alert(err + "OES_texture_float extension"); return}
   if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0){
     alert(err + "Vertex texture"); return}
   var ext = gl.getExtension("OES_element_index_uint");
   if ( !ext ) {alert(err + "OES_element_index_uint extension"); return;}

   prog  = gl.createProgram()
   gl.attachShader(prog, getShader( gl, "shader-vs" ))
   gl.attachShader(prog, getShader( gl, "shader-fs" ))
   gl.linkProgram(prog)

   gl.useProgram(prog)
   var aPosLoc = gl.getAttribLocation(prog, "aPos")
   gl.enableVertexAttribArray( aPosLoc )
   var data = new Float32Array([-1,-1,  1,-1,  -1,1,  1,1])
   gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
   gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
   gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 0, 0)

   pix = new Float32Array(4*n*n)
   var p = 0, h = 1/n1
   for(var i = 0; i < n; i++ )
     for(var j = 0; j < n; j++ ){
       var x = h*(j-n/2),  y = h*(i-n/2)
       pix[p++] = .8*Math.exp(-2500*(x*x + y*y))
       pix[p++] = 0;  pix[p++] = 0;  pix[p++] = 0
     }
   texture1 = gl.createTexture()
   gl.activeTexture(gl.TEXTURE1)
   gl.bindTexture(gl.TEXTURE_2D, texture1)
   gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1)
   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, n, 0, gl.RGBA, gl.FLOAT, pix)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)

   texture2 = gl.createTexture()
   gl.activeTexture(gl.TEXTURE2)
   gl.bindTexture(gl.TEXTURE_2D, texture2)
   gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1)
   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, n, 0, gl.RGBA, gl.FLOAT, pix)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)

   texture = gl.createTexture()
   gl.activeTexture(gl.TEXTURE0)
   gl.bindTexture(gl.TEXTURE_2D, texture)
   gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1)
   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, n, 0, gl.RGBA, gl.FLOAT, pix)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)

   FBO = gl.createFramebuffer()
   gl.bindFramebuffer(gl.FRAMEBUFFER, FBO)
   gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
       gl.TEXTURE_2D, texture, 0)
   FBO1 = gl.createFramebuffer()
   gl.bindFramebuffer(gl.FRAMEBUFFER, FBO1)
   gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
       gl.TEXTURE_2D, texture1, 0)
   FBO2 = gl.createFramebuffer()
   gl.bindFramebuffer(gl.FRAMEBUFFER, FBO2)
   gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
       gl.TEXTURE_2D, texture2, 0)
   if( gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE)
     alert(err + "FLOAT as the color attachment to an FBO")

   sampLoc  = gl.getUniformLocation(prog, "samp")
   samp1Loc = gl.getUniformLocation(prog, "samp1")

   prog_show  = gl.createProgram()
   gl.attachShader(prog_show, getShader( gl, "shader-vs-show" ))
   gl.attachShader(prog_show, getShader( gl, "shader-fs-show" ))
   var posLocation = 2
   gl.bindAttribLocation(prog_show, posLocation, "aPos")
   gl.linkProgram(prog_show)

   gl.useProgram(prog_show)
   gl.uniform1f(gl.getUniformLocation(prog_show, "d"), 1/n)

   var pt = new Float32Array(2*n*n)
   p = 0
   for(var i = 0; i < n; i++ )
     for(var j = 0; j < n; j++ ){
       pt[p++] = h*j;  pt[p++] = h*i
     }
   var ind = new Uint32Array(2*n1*(n+1))
   p = 0
   var t = 0
   for (var i = 0; i < n1; i++ ){
     for (var j = 0; j < n; j++ ){
       ind[p++] = t+j;  ind[p++] = t+j+n
     }
     t += n
     ind[p++] = t+n-1;  ind[p++] = t
   }
   gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
   gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, ind, gl.STATIC_DRAW);

   gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
   gl.bufferData(gl.ARRAY_BUFFER, pt, gl.STATIC_DRAW)
   gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0)
   gl.enableVertexAttribArray( posLocation )

   prMatrix = new CanvasMatrix4()
   prMatrix.perspective(45, c_w/c_h, .1, 100)
   gl.uniformMatrix4fv( gl.getUniformLocation(prog_show,"prMatrix"),
      false, new Float32Array(prMatrix.getAsArray()) )
   mvMatrix = new CanvasMatrix4()
   rotMat = new CanvasMatrix4()
   rotMat.makeIdentity()
   rotMat.rotate(-45, 1,0,0)
   mvMatLoc = gl.getUniformLocation(prog_show,"mvMatrix")

   gl.enable(gl.DEPTH_TEST)
   gl.clearColor(0, 0, 0, 1)
   timer = setInterval(fr, 500)
   time = new Date().getTime()
   animation = "animate"
   anim()

  canvas.resize = function (){
    c_w = window.innerWidth - 50;  c_h = window.innerHeight - 10
    canvas.width = c_w;   canvas.height = c_h
    prMatrix.makeIdentity()
    prMatrix.perspective(45, c_w/c_h, .1, 100)
    gl.uniformMatrix4fv( gl.getUniformLocation(prog_show,"prMatrix"),
      false, new Float32Array(prMatrix.getAsArray()) )
    drawScene()
  }
}
function draw(){
   gl.viewport(0, 0, n, n)

   gl.useProgram(prog)
   gl.uniform1i(sampLoc, 0)
   gl.uniform1i(samp1Loc, 1)
   gl.bindFramebuffer(gl.FRAMEBUFFER, FBO2)
   gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)

   gl.uniform1i(sampLoc, 1)
   gl.uniform1i(samp1Loc, 2)
   gl.bindFramebuffer(gl.FRAMEBUFFER, FBO)
   gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)

   gl.uniform1i(sampLoc, 2)
   gl.uniform1i(samp1Loc, 0)
   gl.bindFramebuffer(gl.FRAMEBUFFER, FBO1)
   gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)

   drawScene()
   frames++
}
function drawScene(){
   gl.viewport(0, 0, c_w, c_h)
   gl.bindFramebuffer(gl.FRAMEBUFFER, null)
   gl.useProgram(prog_show)
   rotMat.rotate(xRot/3, 1,0,0);  rotMat.rotate(yRot/3, 0,1,0)
   rotMat.rotate(zRot, 0,0,1)
   yRot = xRot = zRot = 0
   mvMatrix.makeIdentity()
   mvMatrix.translate(-.5, -.5, 0)
   mvMatrix.multRight( rotMat )
   mvMatrix.translate(0, 0, transl)
   gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
   gl.uniformMatrix4fv( mvMatLoc, false, new Float32Array(mvMatrix.getAsArray()) )
   gl.drawElements(gl.TRIANGLE_STRIP, 2*n1*(n+1) - 2, gl.UNSIGNED_INT, 0)
}
function anim(){
   draw()
   switch ( animation ){
     case "reset":
      gl.bindTexture(gl.TEXTURE_2D, texture1)
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, n, 0, gl.RGBA, gl.FLOAT, pix)
      animation = "animate"
      gl.bindTexture(gl.TEXTURE_2D, texture)
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, n, 0, gl.RGBA, gl.FLOAT, pix)
     case "animate":
       if (delay == 0) requestAnimationFrame(anim)
       else setTimeout("requestAnimationFrame(anim)", delay)
       break
     case "stop":
       break
   }
}
function run(v) {
  if( animation == "animate" ){
    animation = "stop"
    document.getElementById('runBtn').value = "Run "}
  else{
    animation = "animate"
    document.getElementById('runBtn').value = "Stop"
    anim()
  }
}
function reset() {
  if( animation == "stop" ){
    animation = "reset"
    document.getElementById('runBtn').value = "Stop"
    anim()}
  else animation = "reset"
}
function fr(){
  var ti = new Date().getTime()
  var fps = Math.round(1000*frames/(ti - time))
  document.getElementById("framerate").value = fps
  frames = 0;  time = ti
}
function setDelay(val) {
  delay = parseInt(val)
}
</script>

</head>
<body onload="main()" onresize="canvas.resize()">
   <canvas id="canvas" width="512" height="512"></canvas>
<br><button onclick="reset()">Reset</button>
<input type="button" onclick="run()" value="Stop" size="1" id="runBtn">
delay<input size="2" value="0" onchange="setDelay( this.value )">
framerate:<input size="2" id="framerate">fps

<br>Use your fingers or mouse to control the model
(hold <i>shift</i> key or use mouse wheel to zoom it).
Canvas is matched to your browser window.

<p>Waves on membrane is just a sum of <a href="flat_wave.htm">Flat Wave</a> and
<a href="big_hat.htm">Terrain</a> applications. Accurate manipulations with
<i>gl.viewport()</i> are added only.

<hr><a href="contents.htm">Simulations on GPU</a>
<br><i>updated</i> 4 Jan 2011
</body>
</html>
